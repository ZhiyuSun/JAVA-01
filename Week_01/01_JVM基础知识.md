# JVM核心技术

## 1. JVM基础知识

Java 是一种面向对象、静态类型、编译执行，
有VM/GC 和运行时、跨平台的高级语言。

文件系统 的字节码文件，经由虚拟机类加载器，转成对象实例

## 2. 字节码技术

Java bytecode 由单字节（byte）的指令组成，理论上最多支持256 个操作码（opcode）。
实际上Java 只使用了200左右的操作码， 还有一些操作码则保留给调试操作。

根据指令的性质，主要分为四个大类：
1. 栈操作指令，包括与局部变量交互的指令
2. 程序流程控制指令
3. 对象操作指令，包括方法调用指令
4. 算术运算以及类型转换指令

Javac Hello.java
Javap -c Hello.class

JVM是基于栈操作的，load和store是最常用的操作

javap -c -verbose Hello.class  更详细的信息

javac -g Hello.java 本地变量表

JVM操作的栈，操作的是本地变量表

再来点复杂点的，比如四则运算的例子

学习字节码的好处：了解Java底层是怎么执行的

字节码是为了给JVM做一个虚拟的计算机，类似于汇编，通用的计算能力

通过字节码可以看出：String +是StringBuilder的语法糖，for : 是语法糖

## 3. JVM类加载器

### 类的生命周期

1. 加载（Loading）：找Class 文件
2. 验证（Verification）：验证格式、依赖
3. 准备（Preparation）：静态字段、方法表
4. 解析（Resolution）：符号解析为引用
5. 初始化（Initialization）：构造器、静态变
量赋值、静态代码块
6. 使用（Using）
7. 卸载（Unloading）

### 类的加载时机

1. 当虚拟机启动时，初始化用户指定的主类，就是启动执行的main 方法所在的类；
2. 当遇到用以新建目标类实例的new 指令时，初始化new 指令的目标类，就是new
一个类的时候要初始化；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了default 方法，那么直接实现或者间接实现该接口的类的初始化，
会触发该接口的初始化；
7. 使用反射API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用
要么是已经有实例了，要么是静态方法，都需要初始化；
8. 当初次调用MethodHandle 实例时，初始化该MethodHandle 指向的方法所在的
类。

### 不会初始化（可能会加载）

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不
会触发定义常量所在的类。
4. 通过类名获取Class 对象，不会触发类的初始化，Hello.class 不会让Hello 类初始
化。
5. 通过Class.forName 加载指定类时，如果指定参数initialize 为false 时，也不会触
发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName
（“jvm.Hello”）默认会加载Hello 类。
6. 通过ClassLoader 默认的loadClass 方法，也不会触发初始化动作（加载了，但是
不初始化）。

### 三类加载器：
1. 启动类加载器（BootstrapClassLoader）
2. 扩展类加载器（ExtClassLoader）
3. 应用类加载器（AppClassLoader）

加载器特点：
1. 双亲委托
2. 负责依赖
3. 缓存加载

（这一趴有点难）


### 添加引用类的几种方式

1. 放到JDK 的lib/ext 下，或者-Djava.ext.dirs
2. java –cp/classpath 或者class 文件放到当前路径
3. 自定义ClassLoader 加载
4. 拿到当前执行类的ClassLoader，反射调用addUrl 方法添加Jar 或路径(JDK9 无效)。

### 4. JVM内存模型

每个线程都只能访问自己的线程栈。
每个线程都不能访问（看不见）其他线程的局部变量。
所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。
线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。
堆内存中包含了Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如Byte，Integer，Long 等）。
不管是创建一个对象并将其赋值给局部变量， 还是赋值给另一个对象的成员变量， 创建的对象都会被保存到堆内存中。

如果是原生数据类型的局部变量，
那么它的内容就全部保留在线程栈上。
如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。
对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。
类的静态变量则和类定义一样都保存在堆中。

总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；
对象、对象成员与类定义、静态变量在堆上。
堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问, 只要他们能拿到对象的引用地址。
如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。
如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的
局部变量副本是独立的。

### JVM内存整体结构

每启动一个线程，JVM 就会在栈空间栈分配对应的线程栈, 比如1MB 的空间（-Xss1m）。
线程栈也叫做Java 方法栈。如果使用了JNI 方法，则会分配一个单独的本地方法栈(Native Stack)。
线程执行过程中，一般会有多个方法组成调用栈（Stack Trace）, 比如A 调用B，B调用C。。。每执行到一个方法，就会创建对应的栈帧（Frame）。

栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。

比如返回值需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及class 指针（标识这个栈帧对应的是哪个类的方法, 指向非堆里面的Class 对象）。

堆内存是所有线程共用的内存空间，JVM 将Heap 内存分为年轻代（Young generation）和老年代（Old generation, 也叫Tenured）两部分。
年轻代还划分为3 个内存池，新生代（Edenspace）和存活区（Survivor space）, 在大部分GC 算法中有2 个存活区（S0, S1），在我们可以观察到的任何时刻，S0 和S1 总有一个是空的,但一般较小，也不浪费多少空间。

Non-Heap 本质上还是Heap，只是一般不归GC管理，里面划分为3 个内存池。

Metaspace, 以前叫持久代（永久代, Permanentgeneration）, Java8 换了个名字叫Metaspace.CCS, Compressed Class Space, 存放class 信息的，和Metaspace 有交叉。

Code Cache, 存放JIT 编译器编译后的本地机器代码。

注：非堆是jconsole里面的。jconsole是JDK自带的工具

预习材料里很详细

### CPU和内存行为

### JMM

JMM 规范对应的是“[JSR-133. Java Memory Model and Thread
Specification]”，《Java 语言规范》的[$17.4. Memory Model章节] 

JMM 规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了Java 并发程序真正的跨平台。

所有的对象(包括内部的实例成员变量)，static 变量，以及数组，都必须存放到堆内存中。

局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。

多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象就称之为“冲突”。

可以被其他线程影响或感知的操作，称为线程间的交互行为， 可分为： 读取、写入、同步操作、外部操作等等。其中同步操作包括：对volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。

JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。

## 5. JVM启动参数

（课件只是大纲和重要的点，大家要自己去练，写代码，变成自己的）

1. 系统属性参数
2. 运行模式参数
3. 堆内存设置参数
4. GC 设置参数
5. 分析诊断参数
6. JavaAgent 参数

### JVM启动参数——运行模式

1. -server：设置JVM 使用server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率
很高，适用于生产环境。在具有64 位能力的JDK 环境下将默认启用该模式，而忽略-client 参
数。
2. -client ：JDK1.7 之前在32位的x86 机器上的默认值是-client 选项。设置JVM 使用client 模
式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或
者PC 应用开发和调试。此外，我们知道JVM 加载字节码后，可以解释执行，也可以编译成本
地代码再执行，所以可以配置JVM 对字节码的处理模式：
3. -Xint：在解释模式（interpreted mode）下运行，-Xint 标记会强制JVM 解释执行所有的字节
码，这当然会降低运行速度，通常低10倍或更多。
4. -Xcomp：-Xcomp 参数与-Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地
代码，从而带来最大程度的优化。【注意预热】
5. -Xmixed：-Xmixed 是混合模式，将解释模式和编译模式进行混合使用，有JVM 自己决定，这
是JVM 的默认模式，也是推荐模式。我们使用java -version 可以看到mixed mode 等信息。

### JVM启动参数——堆内存

-Xmx, 指定最大堆内存。如-Xmx4g. 这只是限制了Heap 部分的最大值为4g。
这个内存不包括栈内存，也不包括堆外使用的内存。
-Xms, 指定堆内存空间的初始大小。如-Xms4g。而且指定的内存大小，并
不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。专用服务
器上需要保持–Xms 和–Xmx 一致，否则应用刚启动可能就有好几个FullGC。
当两者配置不一致时，堆内存扩容可能会导致性能抖动。
-Xmn, 等价于-XX:NewSize，使用G1 垃圾收集器不应该设置该选项，在其
他的某些业务场景下可以设置。官方建议设置为-Xmx 的1/2 ~ 1/4.
-XX：MaxPermSize=size, 这是JDK1.7 之前使用的。Java8 默认允许的
Meta空间无限大，此参数无效。
-XX：MaxMetaspaceSize=size, Java8 默认不限制Meta 空间, 一般不允许设
置该选项。
-XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参
数跟-Dsun.nio.MaxDirectMemorySize 效果相同。
-Xss, 设置每个线程栈的字节数。例如-Xss1m 指定线程栈为1MB，与-
XX:ThreadStackSize=1m 等价

Xmx-不要超过系统可用内存的60%-80%
4g: 配3.2g

