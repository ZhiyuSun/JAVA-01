# Java并发编程

JVM，NIO, 并发编程，基础里必问的
数据库相关优化，分库分表，分布式，缓存，队列，rpc，微服务

最后三个模块，讲技术架构，重构，软实力

作业30%，面技术没问题

## 多线程基础

### 为什么会有多线程

本质原因是摩尔定律失效-> 多核+分布式时代的来临。

知鱼君注：硬件发展的快，但现在摩尔定律到头了
单机多核还是不够，这时候就要分布式

多CPU 核心意味着同时操作系统有更多的并行计算资源可以使用。
操作系统以**线程**作为基本的调度单元。

单线程是最好处理不过的。
线程越多，管理复杂度越高。

跟我们程序员都喜欢自己单干一样。
《人月神话》里说加人可能干得更慢。

可见多核时代的编程更有挑战。

线程和进程的区别：
进程是操作系统分配资源的基本单位，CPU运行的时候以线程为调度单位
进程是资源的分配单位，线程是CPU调度的最小单位

秦老师：90%的程序员写的多线程都是错的

### Java线程的创建过程

Java提供了Thread类，Java层面
start方法，JVM的JavaThread
创建了操作系统线程,os层面

Java里的线程是裸线程，只要new起来，就对应操作系统里的一个真实的线程

守护线程，setDaemon


## Java多线程*

## Thread类

## 线程安全*

### 并发相关的性质

**原子性**：原子操作，注意跟事务ACID 里原子性的区别与联系

对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

**可见性**：对于可见性，Java 提供了volatile 关键字来保证可见性。

当一个共享变量被volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

另外，通过synchronized 和Lock 也能够保证可见性，synchronized 和Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。

volatile 并不能保证原子性。

**有序性**：Java 允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影
响到多线程并发执行的正确性。可以通过volatile 关键字来保证一定的“有序性”（synchronized 和Lock
也可以）。
happens-before 原则（先行发生原则）：
1. 程序次序规则：一个线程内，按照代码先后顺序
2. 锁定规则：一个unLock 操作先行发生于后面对同一个锁的lock 操作
3. Volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A 先行发生于操作B，而操作B 又先行发生于操作C，则可以得出A 先于C
5. 线程启动规则：Thread 对象的start() 方法先行发生于此线程的每个一个动作
6. 线程中断规则：对线程interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join() 方法结束、
Thread.isAlive() 的返回值手段检测到线程已经终止执行
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize() 方法的开始

### volatile

### final

## 线程池原理与应用*

### 线程池
1. Excutor: 执行者– 顶层接口
2. ExcutorService: 接口API
3. ThreadFactory: 线程工厂
4. Executors: 工具类


## 总结回顾与作业实践


非常推荐《Java并发编程实践》

计算机密集型：CPU核心数，IO密集型，一倍以上

复盘了才能真正的总结，变成自己的，形成体系
作业做了，才能形成直观的感性的认识

怎样提升自己的能力：把手上的项目重构好了，参加开源项目

如果项目中没有用到高并发，怎么应对高并发面试：先把这个课学完

