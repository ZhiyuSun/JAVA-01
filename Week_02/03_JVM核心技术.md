# JVM核心技术

这节课windows需要用到性能工具，super benchmark，预习资料，讲师秦金卫资料JVM里面GClogAnalysize.java

开头讲的东西特别好，潜力就看你额外学了多少东西

研究新技术，比如换了GC，没改代码，效果就这么好，新技术提升了生产力

更开放的心态，接触更多新的技术，有自己的想法，决定了你是否有发展潜力

新技术就像历史前进的车轮，如果你不能乘上这个轮子，你早晚会被它碾碎

所以我们要学习底层的技术，哪怕你现在工作中用不着，这也是把你和相同级别的人区分的一种方式。

复习回顾：内存分区，gc等

堆内存不能跟我们内存一样大，只是Java使用的一小部分

## GC日志解读与分析

Java8默认GC策略并行GC
Java9-15默认的是G1

java -Xmx4g -XX:useParallelGc GcLogAnalsis

GCLogAnalysis.java 模拟GC小工具

结论：堆内存并不是越大越好

有个命令可以把GC的日志打印出来

堆内存太小，会导致OOM
堆内存太大，堆暂停的时间太长

建议：堆内存的使用在不影响系统性能的情况下，尽量的小

minorGC一般是Young GC
MajorGC一般是Full GC

Young GC
Full GC(young gc + old gc)
并行GC会导致业务暂停

还可以测试，同一个Xmx，在不同的GC下的情况

在性能测试环境，通过堆内存和GC的组合，来确定最优的配置
资源利用率不是我们应该直接关注的指标，所以我们需要关注性能指标，反过来看资源利用率

不同gc的延迟对比，一版情况下 zgc << g1 ~ cms < parallel < serial

gc是计算密集型，gc特别频繁，肯定是会大量消耗CPU的

系统非常健康的情况下，young GC频率 << Full GC


脱离场景谈性能都是耍流氓

gceasy.io 把gc日志复制进去，帮助分析

## JVM线程堆栈数据分析

JVM 内部线程主要分为以下几种：
- VM 线程：单例的 VMThread 对象，负责执行 VM 操作，下文将对此进行讨论;
- 定时任务线程：单例的 WatcherThread 对象， 模拟在VM 中执行定时操作的计时器中断；
- GC 线程：垃圾收集器中，用于支持并行和并发垃圾回收的线程;
- 编译器线程： 将字节码编译为本地机器代码;
- 信号分发线程：等待进程指示的信号，并将其分配给Java 级别的信号处理方法。

线程多了，上下文切换的开销会很大，一般情况下，不建议开非常多的线程


安全点：
1. 方法代码中被植入的安全点检测入口；
2. 线程处于安全点状态：线程暂停执行，这个时候线程栈不再发生改变；
3. JVM 的安全点状态：所有线程都处于安全点状态。
JVM 支持多种方式来进行线程转储：
1. JDK 工具, 包括: jstack 工具, jcmd 工具, jconsole, jvisualvm, Java Mission Control 等；
2. Shell 命令或者系统控制台, 比如 Linux 的 kill -3，Windows 的 Ctrl + Break 等；
3. JMX 技术， 主要是使用 ThreadMxBean。

fastthread.io

小内存，并行GC和CMS是主流，jdk10+，cms被g1取代了

Xmx < jvm进程的内存
Xmx最大堆内存，只是jvm使用的一部分内存。

## 内存分析与相关工具

对象头和对象引用

在64位 JVM 中，对象头占据的空间是 12-byte(=96bit=64+32)，但是以8字节对齐，所以一
个空类的实例至少占用16字节。
在32位 JVM 中，对象头占8个字节，以4的倍数对齐(32=4*8)。
所以 new 出来很多简单对象，甚至是 new Object()，都会占用不少内容哈。
通常在32位 JVM，以及内存小于 -Xmx32G 的64位JVM 上(默认开启指针压缩)，一个引用占的内存默认是4个字节。
因此，64位 JVM 一般需要多消耗堆内存。

包装类型

比原生数据类型消耗的内存要多，详情可以参考JavaWorld ：
Integer：占用16字节(头部8+4=12，数据4字节)，因为 int 部分占4个字节。 所以使用 Integer 比原生类型 int 要多消耗 300% 的内存。
Long：一般占用24个字节(头部8+4+数据8=20字节，再对齐)，当然，对象的实际大小由底层平台的内存对齐确定，具体由特定 CPU平台的 JVM 实现决
定。 看起来一个 Long 类型的对象，比起原生类型long 多占用了8个字节（也多消耗200%）。

多维数组：在二维数组 int[dim1][dim2] 中，每嵌套的数组 int[dim2] 都是一个单独的 Object，会额外占用16字节的空间。当数组维度更大时，
这种开销特别明显。
int[128][2] 实例占用3600字节。 而 int[256] 实例则只占用1040字节。里面的有效存储空间是一样的，3600 比起1040多了246%的额外开销。在
极端情况下，byte[256][1]，额外开销的比例是19倍!
String: String 对象的空间随着内部字符数组的增长而增长。当然，String 类的对象有24个字节的额外开销。
对于10字符以内的非空 String，增加的开销比起有效载荷（每个字符2字节 + 4 个字节的 length），多占用了100% 到 400% 的内存。

对齐是绕不过去的问题

我们可能会认为，一个 X 类的实例占用17字节的空间。 但是由于需要对齐(padding)，JVM 分配的内存是8字节的整数倍，所以占用的空间不是17字节,而是24字节。

OutOfMemoryError: Java heap space
创建新的对象时，堆内存中的空间不足以存放新创建的对象
产生的原因，很多时候就类似于将 XXL 号的对象，往 S 号的 Java heap space 里面塞。其实清楚
了原因，问题就很容易解决了：只要增加堆内存的大小，程序就能正常运行。
另外还有一些情况是由代码问题导致的：
• 超出预期的访问量/数据量：应用系统设计时，一般是有 “容量” 定义的，部署这么多机器，用来
处理一定流量的数据/业务。 如果访问量突然飙升，超过预期的阈值，类似于时间坐标系中针尖
形状的图谱。那么在峰值所在的时间段，程序很可能就会卡死、并触发
java.lang.OutOfMemoryError: Java heap space错误。
• 内存泄露(Memory leak)：这也是一种经常出现的情形。由于代码中的某些隐蔽错误，导致系统
占用的内存越来越多。如果某个方法/某段代码存在内存泄漏，每执行一次，就会（有更多的垃圾
对象）占用更多的内存。随着运行时间的推移，泄漏的对象耗光了堆中的所有内存，那么
java.lang.OutOfMemoryError: Java heap space 错误就爆发了。


OutOfMemoryError: PermGen space/OutOfMemoryError: Metaspace
java.lang.OutOfMemoryError: PermGen space 的主要原因，是加载到内存中的
class 数量太多或体积太大，超过了 PermGen 区的大小。
解决办法：增大 PermGen/Metaspace
-XX:MaxPermSize=512m
-XX:MaxMetaspaceSize=512m
高版本 JVM 也可以：
-XX:+CMSClassUnloadingEnabled

OutOfMemoryError: Unable to create new native thread
java.lang.OutOfMemoryError: Unable to create new native thread 错误是程序创建
的线程数量已达到上限值的异常信息。
解决思路：
1. 调整系统参数 ulimit -a，echo 120000 > /proc/sys/kernel/threads-max
2. 降低 xss 等参数
3. 调整代码，改变线程创建和使用方式

## JVM问题分析调优经验

1、高分配速率(High Allocation Rate)
分配速率(Allocation rate)表示单位时间内分配的内存量。通常
使用 MB/sec作为单位。上一次垃圾收集之后，与下一次GC开
始之前的年轻代使用量，两者的差值除以时间,就是分配速率。
分配速率过高就会严重影响程序的性能，在JVM中可能会导致
巨大的GC开销。
正常系统：分配速率较低 ~ 回收速率 -> 健康
内存泄漏：分配速率 持续大于 回收速率 -> OOM
性能劣化：分配速率很高 ~ 回收速率 -> 亚健康

思考一个问题，
分配速率，到底影响什么？
想一想，new出来的对象，在什么地方。
答案就是，Eden。
假如我们增加Eden，会怎么样。
考虑蓄水池效应。
最终的效果是，影响Minor GC的次数和时间，进而影响吞吐量。
在某些情况下，只要增加年轻代的大小，即可降低分配速率过高所造成的影响。
增加年轻代空间并不会降低分配速率，但是会减少GC的频率。如果每次GC后只
有少量对象存活，minor GC 的暂停时间就不会明显增加。

2、过早提升(Premature Promotion)
提升速率(promotion rate)用于衡量单位时间内从年轻代提升到
老年代的数据量。一般使用 MB/sec 作为单位, 和分配速率类
似。
JVM会将长时间存活的对象从年轻代提升到老年代。根据分代
假设，可能存在一种情况，老年代中不仅有存活时间长的对象,，
也可能有存活时间短的对象。这就是过早提升：对象存活时间
还不够长的时候就被提升到了老年代。
major GC 不是为频繁回收而设计的，但 major GC 现在也要
清理这些生命短暂的对象，就会导致GC暂停时间过长。这会严
重影响系统的吞吐量。

GC之前和之后的年轻代使用量以及堆内存使用量。
这样就可以通过差值算出老年代的使用量。
和分配速率一样，提升速率也会影响GC暂停的频
率。但分配速率主要影响 minor GC，而提升速
率则影响 major GC 的频率。
有大量的对象提升，自然很快将老年代填满。老
年代填充的越快，则 major GC 事件的频率就会
越高。

一般来说过早提升的症状表现为以下形式：
1. 短时间内频繁地执行 full GC
2. 每次 full GC 后老年代的使用率都很低，在10-
20%或以下
3. 提升速率接近于分配速率
要演示这种情况稍微有点麻烦，所以我们使用特殊
手段，让对象提升到老年代的年龄比默认情况小很
多。指定GC参数 -Xmx24m -XX:NewSize=16m
-XX:MaxTenuringThreshold=1，运行程序之后，
可以看到下面的GC日志。

解决这类问题，需要让年轻代存放得下暂存的数据，有两种简
单的方法：
一是增加年轻代的大小，设置JVM启动参数，类似这样：-
Xmx64m -XX:NewSize=32m，程序在执行时，Full GC 的次
数自然会减少很多，只会对 minor GC的持续时间产生影响。
二是减少每次批处理的数量，也能得到类似的结果。
至于选用哪个方案，要根据业务需求决定。 在某些情况下，业
务逻辑不允许减少批处理的数量，那就只能增加堆内存，或者
重新指定年轻代的大小。 如果都不可行，就只能优化数据结构，
减少内存消耗。
但总体目标依然是一致的：让临时数据能够在年轻代存放得下。


## GC疑难情况问题分析

1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等， 基础服务、外部 API
依赖 。
2、查看系统资源和监控信息：
硬件信息、操作系统平台、系统架构；
排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发
竞争等情况；
排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调
整、超时、连接数。
3、查看性能指标，包括实时监控、历史数据。可以发现 假死，卡顿、响应变慢等现象；
排查数据库， 并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查
询数据量、redo日志、undo、 binlog 日志、代理、工具 BUG。可以考虑的优化包括： 集群、主备、只
读实例、分片、分区；
大数据，中间件，JVM 参数。
4、排查系统日志， 比如重启、崩溃、Kill 。
5、APM，比如发现有些链路请求变慢等等。

6、排查应用系统
排查配置文件: 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、APM 配置、
内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC 问题等等；
GC 问题， 确定 GC 算法、确定 GC 的 KPI，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标：
内存分配速度，分代提升速度，内存使用率等数据。适当时修改内存配置；
排查线程, 理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁；
排查代码， 比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三
方库、XSS、CORS、正则；
单元测试： 覆盖率、边界值、Mock 测试、集成测试。
7、 排除资源竞争、坏邻居效应
8、疑难问题排查分析手段
DUMP 线程\内存；
抽样分析\调整代码、异步化、削峰填谷。

这个案例挺有意思的

## JVM常见面试问题汇总

一定要自己动手做实验，否则只有一个印象

面试时衡量一个人说的真和假，就看他说的具不具体

形成自己的总结，否则过一两月就忘了

只要找到性能瓶颈，就解决了问题的一半