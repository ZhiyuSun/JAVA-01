# 分布式事务

## 分布式事务*

### 为什么需要分布式事务？

业务系统的复杂度提升，数据量的增加，比如导致出现分布式事务。

### 什么叫分布式事务

分布式条件下，多个节点操作的整体事务一致性。
特别是在微服务场景下，业务A 和业务B 关联，事务A 成功，事务B 失败，由于跨系统，
就会导致不被感知。此时从整体来看，数据是不一致的。
此时，业务系统只能拿到不完全的A 服务数据，缺失B 服务的数据。

### 如何实现分布式下的一致性

典型情况下是两个思路：
1、理想状态：直接想单机数据库事务一样，多个数据库自动通过某种协调机制，实现了跨数据库节点的一致性。
使用场景：要求严格的一致性，比如金融交易类业务。

2、一般情况：可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿，等等方
式，实现数据的最终状态一致性。
使用场景：准实时或非实时的处理，比如T+1 的各类操作，或者电商类操作。


1、强一致: XA
2、弱一致:
1) 不用事务，业务侧补偿冲正
2) 所谓的柔性事务，使用一套事务框架保证最终一致的事务

## XA 分布式事务*

基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA 分布式事务。
XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

XA分布式事务协议

XA 接口
xa_start ：负责开启或者恢复一个事务分支
xa_end： 负责取消当前线程与事务分支的关联
xa_prepare：询问RM 是否准备好提交事务分支
xa_commit：通知RM 提交事务分支
xa_rollback： 通知RM 回滚事务分支
xa_recover : 需要恢复的XA 事务

存在的问题：
- 同步阻塞问题
- 单点故障
- 数据不一致

XA又叫两阶段事务

## BASE 柔性事务*

本地事务-> XA(2PC) -> BASE
如果将实现了ACID 的事务要素的事务称为刚性事务的话，那么基于BASE 事务要素的事务则称为柔性事务。BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。

- 基本可用（Basically Available）保证分布式事务参与方不一定同时在线。
- 柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。
- 而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。

在ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。

BASE 柔性事务常见模式
1、TCC
通过手动补偿处理
2、AT
通过自动补偿处理

## TCC/AT 以及相关框架*

BASE 柔性事务TCC
TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有服务业务的Try 状态来操作，如果都成功，则进行Confirm 操作，如果任意一个Try 发生错误，则全部Cancel。

TCC 使用要求就是业务接口都必须实现三段逻辑：
1.准备操作Try：完成所有业务检查，预留必须的业务资源。
2.确认操作Confirm：真正执行的业务逻辑，不做任何业务检查，只使用Try 阶段预留的业务资源。因此，只要Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。
3.取消操作Cancel：释放Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

（TCC这里再听秦老师讲一遍）

### 柔性事务下隔离级别

事务特性
- 原子性（Atomicity）：正常情况下保证。
- 一致性（Consistency），在某个时间点，会出现A 库和B 库的数据违反一致性要求的情况，但是最终是一致的。
- 隔离性（Isolation），在某个时间点，A 事务能够读到B事务部分提交的结果。
- 持久性（Durability），和本地事务一样，只要commit 则数据被持久。

隔离级别
- 一般情况下都是读已提交（全局锁）、读未提交（无全局锁）。

## hardingSphere 对分布式事务的支持
